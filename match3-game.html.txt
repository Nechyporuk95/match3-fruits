<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>–§—Ä—É–∫—Ç—ã 3 –≤ —Ä—è–¥ ‚Äî 50 —É—Ä–æ–≤–Ω–µ–π</title>
<style>
body {
  margin:0;
  font-family: Arial, sans-serif;
  background: url('https://images.unsplash.com/photo-1507525428034-b723cf961d3e?auto=format&fit=crop&w=1350&q=80') no-repeat center center fixed;
  background-size: cover;
  display:flex;
  flex-direction:column;
  align-items:center;
  justify-content:center;
  min-height:100vh;
}
#menu, #game, #levelSelect, #scores {
  display:none;
  text-align:center;
  background: rgba(255,255,255,0.2);
  padding: 15px;
  border-radius: 15px;
  width:90%;
  max-width:400px;
}
.btn {
  background: #ff7f50;
  border: none;
  padding: 10px 15px;
  margin: 5px;
  border-radius: 12px;
  font-size: 18px;
  color: white;
  cursor: pointer;
  transition: 0.3s;
}
.btn:hover { background: #ff4500; }
#board {
  display: grid;
  gap: 3px;
  margin: 15px auto;
  justify-content: center;
}
.cell {
  display:flex;
  align-items:center;
  justify-content:center;
  font-size: 28px;
  cursor:pointer;
  user-select:none;
  position: relative;
  border-radius: 12px;
  background: rgba(255,255,255,0.4);
  box-shadow: 0 3px 10px rgba(0,0,0,0.25);
  transition: transform 0.3s ease, box-shadow 0.3s ease;
}
.cell.matchGlow {
  animation: glow 0.6s infinite alternate;
}
@keyframes glow {
  0% { box-shadow: 0 0 10px rgba(255,255,255,0.7), 0 0 20px rgba(255,255,255,0.5); }
  100% { box-shadow: 0 0 20px rgba(255,255,255,1), 0 0 30px rgba(255,255,255,0.7); }
}
.cell.remove {
  animation: explode 0.4s forwards;
}
@keyframes explode {
  0% { transform: scale(1) rotate(0deg); opacity:1; }
  50% { transform: scale(1.6) rotate(180deg); opacity:0.7; }
  100% { transform: scale(0) rotate(360deg); opacity:0; }
}
#score, #task {
  font-size:18px;
  margin:8px;
}
.cell.hint { animation: hintBlink 0.8s infinite; }
@keyframes hintBlink {
  0% { transform: scale(1); }
  50% { transform: scale(1.3); }
  100% { transform: scale(1); }
}
#scores table {
  width:100%;
  border-collapse: collapse;
}
#scores th, #scores td {
  padding:5px;
  border-bottom:1px solid #ccc;
  color:#fff;
}
</style>
</head>
<body>
<div id="menu">
  <h1>–§—Ä—É–∫—Ç—ã 3 –≤ —Ä—è–¥</h1>
  <button class="btn" onclick="startGame()">–ù–∞—á–∞—Ç—å –∏–≥—Ä—É</button>
  <button class="btn" onclick="showLevelSelect()">–í—ã–±—Ä–∞—Ç—å —É—Ä–æ–≤–µ–Ω—å</button>
  <button class="btn" onclick="showScores()">–¢–∞–±–ª–∏—Ü–∞ —Ä–µ–∫–æ—Ä–¥–æ–≤</button>
</div>
<div id="levelSelect">
  <h2>–í—ã–±–æ—Ä —É—Ä–æ–≤–Ω—è</h2>
  <div id="levels"></div>
  <button class="btn" onclick="backToMenu()">–ù–∞–∑–∞–¥</button>
</div>
<div id="game">
  <div id="score">–û—á–∫–∏: 0</div>
  <div id="task">–ó–∞–¥–∞–Ω–∏–µ: </div>
  <div id="board"></div>
  <button class="btn" onclick="backToMenu()">–í –º–µ–Ω—é</button>
</div>
<div id="scores">
  <h2>–¢–∞–±–ª–∏—Ü–∞ —Ä–µ–∫–æ—Ä–¥–æ–≤</h2>
  <table>
    <thead><tr><th>–ú–µ—Å—Ç–æ</th><th>–û—á–∫–∏</th></tr></thead>
    <tbody id="scoreTable"></tbody>
  </table>
  <button class="btn" onclick="backToMenu()">–ù–∞–∑–∞–¥</button>
</div>
<audio id="matchSound" src="https://actions.google.com/sounds/v1/cartoon/wood_plank_flicks.ogg"></audio>
<script>
const fruits = ["üçé","üçå","üçá","üçä","üçâ","üçí","üçì","üçç"];
let board=[], size=6, score=0, selected=null, currentLevel=1, collected=0, idleTimer=null;
let unlockedLevels = 1;
const boardEl=document.getElementById("board");
const scoreEl=document.getElementById("score");
const taskEl=document.getElementById("task");
const matchSound=document.getElementById("matchSound");

const LEVELS=[];
for(let i=1;i<=50;i++){
  let sz=6+Math.floor(i/10);
  let type='points', fruit=null, amount=100+i*10;
  if(i%5===2){ type='collect'; fruit=fruits[Math.floor(Math.random()*fruits.length)]; amount=20+Math.floor(i/2); }
  else if(i%5===3){ type='bonus'; fruit=i%2===0?'üçè':'ü•ù'; amount=5+Math.floor(i/3); }
  else if(i%5===4){ type='collect'; fruit=fruits[Math.floor(Math.random()*fruits.length)]; amount=25+Math.floor(i/2); }
  LEVELS.push({size:sz, task:{type, fruit, amount}});
}

function randomFruit(){
  const t=LEVELS[currentLevel-1].task;
  let r=Math.random();
  if(r<0.05) return "üçè";
  if(r<0.1) return "ü•ù";
  if(t.type==='collect' && Math.random()<0.25) return t.fruit;
  return fruits[Math.floor(Math.random()*fruits.length)];
}

function initBoard(){
  size=LEVELS[currentLevel-1].size;
  boardEl.style.gridTemplateColumns=`repeat(${size},50px)`;
  boardEl.style.gridTemplateRows=`repeat(${size},50px)`;
  do{
    board=[]; boardEl.innerHTML='';
    for(let r=0;r<size;r++){
      let row=[];
      for(let c=0;c<size;c++){
        let f=randomFruit();
        row.push(f);
        const cell=document.createElement("div");
        cell.classList.add("cell");
        cell.textContent=f;
        cell.onclick=()=>{selectCell(r,c,cell); resetIdleTimer();};
        boardEl.appendChild(cell);
      }
      row.length && board.push(row);
    }
  }while(findMoves().length===0);
  score=0; collected=0;
  scoreEl.textContent="–û—á–∫–∏: 0"; showTask(); resetIdleTimer();
  resolveBoard();
}

function showTask(){
  const t=LEVELS[currentLevel-1].task;
  if(t.type==='points') taskEl.textContent=`–ó–∞–¥–∞–Ω–∏–µ: –Ω–∞–±—Ä–∞—Ç—å ${t.amount} –æ—á–∫–æ–≤`;
  else taskEl.textContent=`–ó–∞–¥–∞–Ω–∏–µ: ${t.type==='collect'?'—Å–æ–±—Ä–∞—Ç—å':'–∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞—Ç—å'} ${t.amount} ${t.fruit} (—Å–æ–±—Ä–∞–Ω–æ: ${collected}/${t.amount})`;
}

function selectCell(r,c,cell){
  if(!selected){selected={r,c,cell}; cell.style.transform='scale(1.2)';}
  else{
    let sr=selected.r, sc=selected.c;
    if(Math.abs(sr-r)+Math.abs(sc-c)===1){ trySwap(sr,sc,r,c); }
    selected.cell.style.transform='scale(1)'; selected=null;
  }
}

// --- –ê–Ω–∏–º–∞—Ü–∏—è —Ö–æ–¥–∞ —Å —ç—Ñ—Ñ–µ–∫—Ç–æ–º –æ—Ç—Å–∫–æ–∫–∞ ---
function trySwap(r1,c1,r2,c2){
  const cell1 = boardEl.children[r1*size+c1];
  const cell2 = boardEl.children[r2*size+c2];
  [board[r1][c1], board[r2][c2]] = [board[r2][c2], board[r1][c1]];
  renderBoard();

  if(findMatches().length>0){
    resolveBoard();
  } else {
    // –í–æ–∑–≤—Ä–∞—Ç –Ω–∞–∑–∞–¥ —Å ¬´–æ—Ç—Å–∫–æ–∫–æ–º¬ª
    cell1.style.transition='transform 0.15s';
    cell2.style.transition='transform 0.15s';
    cell1.style.transform='translate(' + (c1-c2)*50 + 'px,' + (r1-r2)*50 + 'px) scale(1.1)';
    cell2.style.transform='translate(' + (c2-c1)*50 + 'px,' + (r2-r1)*50 + 'px) scale(1.1)';
    setTimeout(()=>{
      cell1.style.transform='translate(0,0) scale(0.9)';
      cell2.style.transform='translate(0,0) scale(0.9)';
      setTimeout(()=>{
        [board[r1][c1], board[r2][c2]] = [board[r2][c2], board[r1][c1]];
        renderBoard();
        cell1.style.transition=''; cell2.style.transition='';
        cell1.style.transform='scale(1)';
        cell2.style.transform='scale(1)';
      },150);
    },150);
  }
}

function findMatches(){
  let matches=[];
  for(let r=0;r<size;r++)for(let c=0;c<size-2;c++){
    let f=board[r][c];
    if(f && f===board[r][c+1] && f===board[r][c+2]){
      let group=[[r,c],[r,c+1],[r,c+2]]; let cc=c+3; while(cc<size && board[r][cc]===f){ group.push([r,cc]); cc++; }
      matches.push(...group);
    }
  }
  for(let c=0;c<size;c++)for(let r=0;r<size-2;r++){
    let f=board[r][c];
    if(f && f===board[r+1][c] && f===board[r+2][c]){
      let group=[[r,c],[r+1,c],[r+2,c]]; let rr=r+3; while(rr<size && board[rr][c]===f){ group.push([rr,c]); rr++; }
      matches.push(...group);
    }
  }
  return [...new Set(matches.map(x=>x.toString()))].map(x=>x.split(',').map(Number));
}

function removeMatches(matches){ matches.forEach(([r,c])=>{ board[r][c]=null; score+=10; collected++; }); scoreEl.textContent="–û—á–∫–∏: "+score; showTask(); }

function dropFruits(){ for(let c=0;c<size;c++){ let empty=[]; for(let r=size-1;r>=0;r--){ if(!board[r][c]) empty.push(r); else if(empty.length>0){ let newRow=empty.shift(); board[newRow][c]=board[r][c]; board[r][c]=null; empty.push(r); } } for(let e of empty) board[e][c]=randomFruit(); } renderBoard(); }

function renderBoard(){ for(let r=0;r<size;r++)for(let c=0;c<size;c++){ const cell=boardEl.children[r*size+c]; cell.textContent=board[r][c]; cell.classList.remove('remove','hint'); cell.style.transform='scale(1)'; } }

function resolveBoard(){ let matches=findMatches(); if(matches.length>0){ removeMatches(matches); matchSound.play(); setTimeout(()=>{ dropFruits(); resolveBoard(); checkTask(); },400); } else if(findMoves().length===0){ reshuffle(); } }

function checkTask(){ const t=LEVELS[currentLevel-1].task; if((t.type==='points' && score>=t.amount) || (t.type!=='points' && collected>=t.amount)){ saveScore(score); alert(`–£—Ä–æ–≤–µ–Ω—å ${currentLevel} –ø—Ä–æ–π–¥–µ–Ω!`); if(currentLevel>=unlockedLevels && unlockedLevels<LEVELS.length) unlockedLevels++; currentLevel++; if(currentLevel>LEVELS.length) currentLevel=LEVELS.length; initBoard(); updateLevelButtons(); } }

function findMoves(){ let m=[]; function swapTmp(r1,c1,r2,c2){ [board[r1][c1],board[r2][c2]]=[board[r2][c2],board[r1][c1]]; } for(let r=0;r<size;r++)for(let c=0;c<size;c++){ if(c<size-1){ swapTmp(r,c,r,c+1); if(findMatches().length>0)m.push([[r,c],[r,c+1]]); swapTmp(r,c,r,c+1);} if(r<size-1){ swapTmp(r,c,r+1,c); if(findMatches().length>0)m.push([[r,c],[r+1,c]]); swapTmp(r,c,r+1,c);} } return m; }

function reshuffle(){ let flat=board.flat().filter(f=>f); flat.sort(()=>Math.random()-0.5); for(let r=0;r<size;r++) for(let c=0;c<size;c++) board[r][c]=flat[r*size+c]; renderBoard(); if(findMoves().length===0) reshuffle(); }

function resetIdleTimer(){ clearTimeout(idleTimer); clearHint(); idleTimer=setTimeout(showHint,5000); }
function showHint(){ let moves=findMoves(); if(moves.length>0){ let move=moves[Math.floor(Math.random()*moves.length)]; move.forEach(([r,c])=>boardEl.children[r*size+c].classList.add("hint")); } }
function clearHint(){ [...boardEl.children].forEach(cell=>cell.classList.remove("hint")); }

function saveScore(s){ let scores=JSON.parse(localStorage.getItem("scores")||"[]"); scores.push(s); scores.sort((a,b)=>b-a); scores=scores.slice(0,5); localStorage.setItem("scores",JSON.stringify(scores)); }
function showScores(){ document.getElementById("menu").style.display='none'; document.getElementById("scores").style.display='block'; let scores=JSON.parse(localStorage.getItem("scores")||"[]"); let tbody=document.getElementById("scoreTable"); tbody.innerHTML=''; scores.forEach((s,i)=>{ tbody.innerHTML+=`<tr><td>${i+1}</td><td>${s}</td></tr>`; }); }

function startGame(){ document.getElementById('menu').style.display='none'; document.getElementById('levelSelect').style.display='none'; document.getElementById('scores').style.display='none'; document.getElementById('game').style.display='block'; initBoard(); }
function showLevelSelect(){ document.getElementById('menu').style.display='none'; document.getElementById('levelSelect').style.display='block'; updateLevelButtons(); }
function updateLevelButtons(){ const levelsDiv=document.getElementById('levels'); levelsDiv.innerHTML=''; for(let i=1;i<=50;i++){ const btn=document.createElement('button'); btn.className='btn'; btn.textContent='–£—Ä–æ–≤–µ–Ω—å '+i; if(i<=unlockedLevels){ btn.onclick=()=>{currentLevel=i; initBoard(); document.getElementById('levelSelect').style.display='none'; document.getElementById('game').style.display='block';}; } else { btn.disabled=true; btn.style.background='#999'; } levelsDiv.appendChild(btn);} }
function backToMenu(){ document.getElementById('menu').style.display='block'; document.getElementById('game').style.display='none'; document.getElementById('levelSelect').style.display='none'; document.getElementById('scores').style.display='none'; }

document.getElementById('menu').style.display='block';

// --- –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–µ —Å–≤–∞–π–ø—ã –¥–ª—è –º–æ–±–∏–ª—å–Ω—ã—Ö ---
let touchStart = null;
boardEl.addEventListener('touchstart', e => {
  if (e.touches.length===1) {
    const touch = e.touches[0];
    touchStart = { x: touch.clientX, y: touch.clientY };
    const rect = boardEl.getBoundingClientRect();
    const cellSize = rect.width / size;
    const col = Math.floor((touch.clientX - rect.left) / cellSize);
    const row = Math.floor((touch.clientY - rect.top) / cellSize);
    selected = { r: row, c: col };
  }
});
boardEl.addEventListener('touchend', e => {
  if (!touchStart || !selected) return;
  const touch = e.changedTouches[0];
  const dx = touch.clientX - touchStart.x;
  const dy = touch.clientY - touchStart.y;
  const absX = Math.abs(dx), absY = Math.abs(dy);
  const r = selected.r, c = selected.c;

  if (absX>30 || absY>30) { trySwapSwipe(r,c,dx,dy,absX,absY); }
  selected=null; touchStart=null;
});

function trySwapSwipe(r,c,dx,dy,absX,absY){
  if(absX>absY){
    if(dx>0 && c<size-1) trySwap(r,c,r,c+1);
    else if(dx<0 && c>0) trySwap(r,c,r,c-1);
  } else {
    if(dy>0 && r<size-1) trySwap(r,c,r+1,c);
    else if(dy<0 && r>0) trySwap(r,c,r-1,c);
  }
}
</script>
</body>
</html>
